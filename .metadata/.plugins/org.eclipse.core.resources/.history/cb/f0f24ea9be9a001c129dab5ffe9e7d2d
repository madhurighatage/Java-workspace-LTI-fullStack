package com.lti.appl;

import org.junit.Before;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import com.lti.appl.dao.EmpDaoImpl;

@SpringBootTest(classes = ApplApplication.class)
@RunWith(SpringRunner.class)
public class ApplApplicationTests {
	
	@Test
	public void someTest()
	{
		System.out.println(" test case called ");
		
		String str="hello";
		
		Assertions.assertEquals("hello",str);
		
	}
	
	@Autowired
	private WebApplicationContext webApplicationContext;

	//MockMVC class - part of Spring MVC test framework 
	// helps in testing controllers explicitly starting a Servlet container.
	//It disables full auto-configuration and instead apply only configuration relevant to MVC tests.
	//MockMvc is defined as a main entry point for server-side Spring MVC testing.

	private MockMvc mockMvc;
	
	// @Mock a bean from the Spring ApplicationContext
	// Spring Boot -  @MockBean 
	
	@MockBean
    private EmpDaoImpl empDao;

	@Before
	public void setup() {
	
		mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
	}

	@Test
	public void testEmployee() throws Exception {

		mockMvc.perform(get("http://localhost:8080/emp/employee/103"))
				.andExpect(status().isOk())
				//.andExpect(content().contentType("application/json"))
				.andExpect(jsonPath("$.empName").value("Vijay"))
				.andExpect(jsonPath("$.empSal").value(90000));

	}
	/*
	 @Test
	    public void find_bookId() throws Exception {
	        mockMvc.perform(get("/http://localhost:8080/emp/employee/102}"))
	        .andExpect(status()
	        .isNotFound());
	    }

	@Test
    public void find_allEmps() throws Exception {

        List<Employee> empList  = Arrays.asList(
                new Employee(101,"Jay",50000),
                new Employee(101,"Jay",50000),
                new Employee(101,"Jay",50000));
                

        mockMvc.perform(get("http://localhost:8080/emp/listall"))
                .andExpect(content().contentType(("application/json")))
                .andExpect(status().isOk());
                      
        when(empDao.listAllEmployees()).thenReturn(empList);
        
        
        assertEquals(3, empList.size());
        
        // times(1)  ////limit the method call to 1, no less and no more calls are allowed
        
        //We can use Mockito verify methods at the end of the testing method code 
        //to make sure that specified methods are called.
        
        // is listAllEmployees()method has been called 
        verify(empDao, times(1)).listAllEmployees();


       

    }*/

}

/*
steps:

Perform a GET request to url '/api/todo'. Set the logged in user.

Verify that the content type of the response is 'application/json' and its character set 'UTF-8'.

Verify that the returned HTTP status code is 200.

Fetch the collection of todo entries by using JsonPath expression $ and ensure that two todo entries are returned.

Use the JsonPath expressions $[0].id, $[0].description and $[0].title to get the id, description and title of the first todo entry.

Verify that its information is correct.
Use the JsonPath expressions $[1].id, $[1].description and $[1].title to get the id, description and title of the second todo entry. 

Verify that its information is correct.
 */

